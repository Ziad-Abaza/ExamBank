<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Complexity Questions</title>
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Tajawal", sans-serif;
      }
      .glass-card {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      @keyframes fade-in-down {
        0% {
          opacity: 0;
          transform: translateY(-10px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .animate-fade-in-down {
        animation: fade-in-down 0.8s ease-out forwards;
      }
      pre {
        direction: ltr;
        text-align: left;
        white-space: pre;
        padding: 1rem;
        overflow-x: auto;
        border-radius: 0.75rem;
        background-color: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
    </style>
  </head>
  <body
    class="bg-gradient-to-br from-gray-900 via-purple-950 to-black text-white min-h-screen"
  >
    <!-- Header -->
    <header class="text-center py-10 px-4">
      <h1
        class="text-3xl md:text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500 animate-fade-in-down"
      >
        أسئلة التعقيد الزمني
      </h1>
      <p class="mt-3 text-sm text-yellow-400 animate-fade-in-down delay-100">
        حدد التعقيد الزمني لكل كود أدناه وتحقق من إجابتك فورًا
      </p>
      <div
        class="text-center mt-6 w-100 flex gap-4 align-content-center justify-center animate-fade-in-down delay-200"
      >
        <a
          href="tutorial.html"
          class="block text-center mt-6 text-indigo-400 hover:text-indigo-200 transition"
          >عرض المحتوى التعليمي</a
        >
        <span
          class="border-l mt-[22px] border-gray-600 h-[30px] flex align-content-center items-center justify-center text-gray-500"
        ></span>
        <a
          href="index.html"
          class="block text-center mt-6 text-indigo-400 hover:text-indigo-200 transition"
          >الرئيسية </a
        >
      </div>
    </header>
    <!-- Main Container -->
    <main class="max-w-3xl mx-auto px-4 pb-16 space-y-6">
      <div id="quiz-container" class="space-y-6"></div>
      <!-- Pagination -->
      <div
        class="flex justify-between items-center mt-8 p-4 glass-card rounded-xl shadow-lg"
      >
        <button
          id="prev-btn"
          class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded disabled:opacity-40 disabled:cursor-not-allowed transition"
        >
          السابق
        </button>
        <span id="page-info" class="text-sm font-medium text-gray-300"></span>
        <button
          id="next-btn"
          class="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded transition"
        >
          التالي
        </button>
      </div>
    </main>
    <!-- Footer -->
    <footer class="text-center text-xs text-gray-600 py-4">
      © 2025 EgyTech | جميع الحقوق محفوظة
    </footer>
    <!-- JavaScript Logic -->
    <script>
      const QUESTIONS_PER_PAGE = 10;

      const allQuestions = [
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question1(n):\n    for i in range(n):\n        print(i)",
          options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
          correct: 2,
          explanation: "لأن الدالة تنفذ حلقة واحدة فقط تزداد مع n.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question2(n):\n    for i in range(n):\n        for j in range(n):\n            print(i, j)",
          options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
          correct: 3,
          explanation: "لأن هناك حلقتين متداخلتين، وكل منهما تعتمد على n.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question3(n):\n    if n <= 1:\n        return\n    question3(n // 2)\n    print(n)",
          options: ["O(log n)", "O(n)", "O(n log n)", "O(n²)"],
          correct: 0,
          explanation: "لأنها دالة تكرارية وتقلل n إلى النصف في كل مرة.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question4(n):\n    i = 1\n    while i < n:\n        i *= 2",
          options: ["O(log n)", "O(n)", "O(n log n)", "O(n²)"],
          correct: 0,
          explanation:
            "لأن المتغير i يتضاعف في كل خطوة، مما يعني عدد خطوات يتناسب مع log₂(n).",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question5(n):\n    arr = [0] * n\n    for i in range(n):\n        arr[i] = i",
          options: ["O(1)", "O(n)", "O(n²)", "O(log n)"],
          correct: 1,
          explanation:
            "لأن الحذف والوصول في القائمة يأخذ O(1)، لكن الحلقة تأخذ O(n).",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question6(n):\n    for i in range(n):\n        print(i)\n    for j in range(n):\n        print(j)",
          options: ["O(1)", "O(n)", "O(n²)", "O(n log n)"],
          correct: 1,
          explanation: "الحلقتين لا تتداخل، لذا التعقيد يبقى O(n).",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question7(n):\n    for i in range(n):\n        for j in range(i, n):\n            print(i, j)",
          options: ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
          correct: 2,
          explanation: "الحلقة الداخلية تبدأ من i، لذا عدد العمليات ≈ n²/2.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question8(n):\n    i = 1\n    while i < n:\n        i += 1",
          options: ["O(1)", "O(log n)", "O(n)", "O(n²)"],
          correct: 2,
          explanation: "العدد يزيد بمقدار 1 حتى يصل إلى n، أي عدد عمليات = n.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question9(n):\n    for i in range(n):\n        for j in range(n):\n            print(i)\n        print('done')",
          options: ["O(n)", "O(n²)", "O(log n)", "O(n log n)"],
          correct: 1,
          explanation: "لأن هناك حلقتين متداخلتين.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question10(n):\n    for i in range(n):\n        print(i)\n    for j in range(n):\n        for k in range(n):\n            print(k)",
          options: ["O(n)", "O(n²)", "O(n log n)", "O(n + n²)"],
          correct: 1,
          explanation: "الحلقة الثانية هي O(n²)، وهي أكبر من الأولى O(n).",
        },
        {
          question: "ما هو التعقيد المكاني للدالة التالية؟",
          code: "def question11(n):\n    arr = [0] * n\n    for i in range(n):\n        arr[i] = i",
          options: ["O(1)", "O(n)", "O(log n)", "O(n²)"],
          correct: 1,
          explanation: "المصفوفة تحتاج مساحة تتناسب مع n.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question12(n):\n    if n == 0:\n        return 1\n    return question12(n-1) + n",
          options: ["O(1)", "O(n)", "O(log n)", "O(n²)"],
          correct: 1,
          explanation: "الدالة التكرارية تُنادى n مرة.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question13(n):\n    if n <= 1:\n        return\n    question13(n//2)\n    print(n)",
          options: ["O(log n)", "O(n)", "O(n log n)", "O(n²)"],
          correct: 0,
          explanation:
            "القيمة تقسم على 2 في كل استدعاء، لذا عدد الاستدعاءات هو log₂(n).",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question14(n):\n    for i in range(n):\n        binary_search(arr, i)",
          options: ["O(n)", "O(n log n)", "O(n²)", "O(n² log n)"],
          correct: 1,
          explanation:
            "البحث الثنائي O(log n)، والحلقة الخارجية O(n) → المجموع O(n log n).",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question15(n):\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                print(i, j, k)",
          options: ["O(n)", "O(n²)", "O(n³)", "O(n log n)"],
          correct: 2,
          explanation: "ثلاث حلقات متداخلة كل منها يعتمد على n.",
        },
        {
          question: "ما هو التعقيد المكاني للدالة التالية؟",
          code: "def question11(n):\n    arr = [0] * n\n    for i in range(n):\n        arr[i] = i",
          options: ["O(1)", "O(n)", "O(log n)", "O(n²)"],
          correct: 1,
          explanation: "المصفوفة تحتاج مساحة تتناسب مع n.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question12(n):\n    if n == 0:\n        return 1\n    return question12(n-1) + n",
          options: ["O(1)", "O(n)", "O(log n)", "O(n²)"],
          correct: 1,
          explanation: "الدالة التكرارية تُنادى n مرة.",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question13(n):\n    if n <= 1:\n        return\n    question13(n//2)\n    print(n)",
          options: ["O(log n)", "O(n)", "O(n log n)", "O(n²)"],
          correct: 0,
          explanation:
            "القيمة تقسم على 2 في كل استدعاء، لذا عدد الاستدعاءات هو log₂(n).",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question14(n):\n    for i in range(n):\n        binary_search(arr, i)",
          options: ["O(n)", "O(n log n)", "O(n²)", "O(n² log n)"],
          correct: 1,
          explanation:
            "البحث الثنائي O(log n)، والحلقة الخارجية O(n) → المجموع O(n log n).",
        },
        {
          question: "ما هو التعقيد الزمني للدالة التالية؟",
          code: "def question15(n):\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                print(i, j, k)",
          options: ["O(n)", "O(n²)", "O(n³)", "O(n log n)"],
          correct: 2,
          explanation: "ثلاث حلقات متداخلة كل منها يعتمد على n.",
        },

        // إضافة 20 سؤالًا جديدًا:
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question16(n):\n    total = 0\n    for i in range(n):\n        total += i\n    return total",
          options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
          correct: 2,
          explanation: "حلقة واحدة من 0 إلى n-1 → O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question17(n):\n    for i in range(n):\n        for j in range(10):\n            print(i, j)",
          options: ["O(n)", "O(n²)", "O(1)", "O(n log n)"],
          correct: 0,
          explanation: "الحلقة الداخلية ثابتة (10 مرات) → O(10n) = O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question18(n):\n    if n <= 1:\n        return 1\n    return question18(n-1) * question18(n-1)",
          options: ["O(2ⁿ)", "O(n)", "O(log n)", "O(n²)"],
          correct: 0,
          explanation: "كل استدعاء يولد استدعائين متطابقين → O(2ⁿ).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question19(n):\n    for i in range(n):\n        j = n\n        while j > 0:\n            j //= 2\n            print(i, j)",
          options: ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
          correct: 1,
          explanation:
            "الحلقة الداخلية لوغاريتمية → O(log n)، والخارجية O(n) → O(n log n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question20(n):\n    for i in range(n//2):\n        print(i)\n    for j in range(n):\n        print(j)",
          options: ["O(n/2 + n)", "O(n)", "O(n²)", "O(n log n)"],
          correct: 1,
          explanation: "n/2 + n = 1.5n → O(n).",
        },
        {
          question: "ما هو التعقيد المكاني لهذه الدالة؟",
          code: "def question21(n):\n    if n <= 1:\n        return []\n    left = question21(n//2)\n    right = question21(n//2)\n    return left + right",
          options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
          correct: 3,
          explanation: "كل مستوى من الاستدعاء يبني مصفوفة بحجم n → O(n log n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question22(n):\n    for i in range(n):\n        for j in range(i):\n            for k in range(j):\n                print(i, j, k)",
          options: ["O(n³)", "O(n²)", "O(n)", "O(log n)"],
          correct: 0,
          explanation: "عدد التكرارات ≈ n³/6 → O(n³).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question23(n):\n    print(n)\n    return question23(n-1)",
          options: ["O(n)", "O(1)", "O(n²)", "O(log n)"],
          correct: 0,
          explanation:
            "الدالة تستدعي نفسها n مرة قبل الوصول إلى شرط التوقف → O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question24(n):\n    for i in range(n):\n        for j in range(n//2):\n            print(i, j)",
          options: ["O(n²)", "O(n²/2)", "O(n log n)", "O(n)"],
          correct: 0,
          explanation: "n × (n/2) = n²/2 → O(n²).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question25(n):\n    return sum([i for i in range(n)])",
          options: ["O(n)", "O(n²)", "O(1)", "O(log n)"],
          correct: 0,
          explanation: "بناء القائمة يأخذ O(n)، ودالة sum أيضاً O(n) → O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question26(n):\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                break",
          options: ["O(n)", "O(n²)", "O(n log n)", "O(1)"],
          correct: 0,
          explanation:
            "في كل دورة خارجية تنكسر الحلقة الداخلية عند i == j → دورة واحدة → O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question27(n):\n    for i in range(n):\n        for j in range(2*n):\n            print(i, j)",
          options: ["O(2n²)", "O(n²)", "O(n)", "O(n log n)"],
          correct: 1,
          explanation: "n × (2n) = 2n² → O(n²).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question28(n):\n    if n <= 1:\n        return 1\n    return question28(n-1) + question28(n//2)",
          options: ["O(n)", "O(n log n)", "O(2ⁿ)", "O(n²)"],
          correct: 1,
          explanation: "T(n) = T(n-1) + T(n/2) + O(1) → O(n).",
        },
        {
          question: "ما هو التعقيد المكاني لهذه الدالة؟",
          code: "def question29(n):\n    matrix = [[0]*n for _ in range(n)]\n    return matrix",
          options: ["O(n)", "O(n²)", "O(1)", "O(n log n)"],
          correct: 1,
          explanation: "المصفوفة ثنائية الأبعاد بحجم n×n → O(n²).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question30(n):\n    arr = list(range(n))\n    arr.reverse()\n    for x in arr:\n        print(x)",
          options: ["O(n)", "O(n log n)", "O(n²)", "O(1)"],
          correct: 0,
          explanation: "العكس O(n) والطباعة O(n) → المجموع O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question31(n):\n    for i in range(n):\n        if i % 2 == 0:\n            print(i)",
          options: ["O(n)", "O(n/2)", "O(log n)", "O(1)"],
          correct: 0,
          explanation: "نمر على كل i من 0 إلى n-1 → O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question32(n):\n    i = 1\n    while i < n:\n        i *= 3\n        print(i)",
          options: ["O(log₃ n)", "O(log₂ n)", "O(n)", "O(1)"],
          correct: 0,
          explanation:
            "القيمة تتضاعف بمقدار 3 في كل خطوة → عدد الخطوات ≈ log₃(n).",
        },
        {
          question: "ما هو التعقيد المكاني لهذه الدالة؟",
          code: "def question33(n):\n    def helper(k):\n        if k == 0:\n            return []\n        return [k] + helper(k-1)\n    return helper(n)",
          options: ["O(n)", "O(1)", "O(n²)", "O(log n)"],
          correct: 0,
          explanation: "التراكم في القائمة والـ recursion stack يستهلكان O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def question34(n):\n    for i in range(n):\n        for j in range(i*i):\n            print(i, j)",
          options: ["O(n³)", "O(n⁴)", "O(n²)", "O(n)"],
          correct: 0,
          explanation: "مجموع التكرارات ≈ Σ i² for i=0..n = O(n³).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة الخبيثة؟",
          code: "def question35(n):\n    for i in range(n):\n        for j in range(i):\n            for k in range(j):\n                for m in range(k):\n                    print(i,j,k,m)",
          options: ["O(n⁴)", "O(n³)", "O(n²)", "O(n)"],
          correct: 1,
          explanation:
            "عدد التكرارات هو ΣΣΣΣ 1 = O(n³) لأن المستويات الثلاثة الداخلية تعطي O(n³).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q1(n):\n    if n <= 1:\n        return 1\n    return q1(n-1) + q1(n-2)",
          options: ["O(n)", "O(n log n)", "O(2ⁿ)", "O(n²)"],
          correct: 2,
          explanation:
            "دالة فيبوناتشي بدون memoization تؤدي إلى استدعاءات متكررة كثيرة جدًا.",
        },
        {
          question: "ما هو التعقيد المكاني لهذه الدالة؟",
          code: "def q2(n):\n    return [i for i in range(n) if i % 2 == 0]",
          options: ["O(n)", "O(n/2)", "O(log n)", "O(1)"],
          correct: 0,
          explanation: "قائمة بحجم تقريبًا n/2 لكنها تظل O(n) مكانيًا.",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q3(n):\n    return sorted([i for i in range(n)])",
          options: ["O(n log n)", "O(n)", "O(n²)", "O(1)"],
          correct: 0,
          explanation: "بناء القائمة O(n)، ثم الترتيب O(n log n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q4(n):\n    i = 0\n    while i*i < n:\n        i += 1",
          options: ["O(√n)", "O(n)", "O(log n)", "O(n²)"],
          correct: 0,
          explanation: "عدد التكرارات يتوقف عندما i² >= n → i ≈ √n.",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q5(n):\n    for i in range(n):\n        if i == n - 1:\n            for j in range(n):\n                print(i, j)",
          options: ["O(n)", "O(n²)", "O(1)", "O(n log n)"],
          correct: 0,
          explanation: "الحلقة الداخلية تُنفذ مرة واحدة فقط عندما i = n-1.",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q6(n):\n    return [0]*1000",
          options: ["O(1)", "O(n)", "O(log n)", "O(n²)"],
          correct: 0,
          explanation: "الحجم ثابت (1000) لا يعتمد على n.",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q7(n):\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                print(i*j)",
          options: ["O(n)", "O(n²)", "O(1)", "O(n log n)"],
          correct: 0,
          explanation: "الشروط تجعل عدد الطبع يساوي n فقط.",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q8(n):\n    i = n\n    while i > 0:\n        i //= 2",
          options: ["O(log n)", "O(n)", "O(n log n)", "O(n²)"],
          correct: 0,
          explanation: "i يُقسم على 2 في كل خطوة → O(log n).",
        },
        {
          question: "ما هو التعقيد المكاني لهذه الدالة؟",
          code: "def q9(n):\n    return [[0]*i for i in range(n)]",
          options: ["O(n²)", "O(n)", "O(log n)", "O(1)"],
          correct: 0,
          explanation: "مصفوفة غير منتظمة بحجم مجموعي O(n²).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q10(n):\n    return max([i for i in range(n)])",
          options: ["O(n)", "O(1)", "O(log n)", "O(n log n)"],
          correct: 0,
          explanation: "إنشاء القائمة O(n)، واستخدام max أيضًا O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q11(n):\n    return n * (n + 1) // 2",
          options: ["O(1)", "O(n)", "O(n²)", "O(log n)"],
          correct: 0,
          explanation: "عملية حسابية مباشرة → O(1).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q12(n):\n    for i in range(n):\n        if i % 100 == 0:\n            print(i)",
          options: ["O(n)", "O(n/100)", "O(log n)", "O(1)"],
          correct: 0,
          explanation: "حتى لو نطبع قليلًا، الحلقة نفسها تمر على كل n.",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q13(n):\n    a = b = 1\n    for i in range(n):\n        a, b = b, a + b",
          options: ["O(n)", "O(2ⁿ)", "O(log n)", "O(n²)"],
          correct: 0,
          explanation: "حساب فيبوناتشي بطريقة تكرارية فعالة → O(n).",
        },
        {
          question: "ما هو التعقيد المكاني لهذه الدالة؟",
          code: "def q14(n):\n    return [i*i for i in range(n)]",
          options: ["O(n)", "O(1)", "O(n²)", "O(log n)"],
          correct: 0,
          explanation: "كل عنصر محفوظ في قائمة → O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q15(n):\n    for i in range(n):\n        for j in range(i*i):\n            for k in range(j):\n                print(i, j, k)",
          options: ["O(n⁴)", "O(n³)", "O(n²)", "O(n log n)"],
          correct: 0,
          explanation: "Σ i² × i = Σ i³ → O(n⁴).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q16(n):\n    for i in range(n):\n        if i == n // 2:\n            break",
          options: ["O(n)", "O(n/2)", "O(1)", "O(log n)"],
          correct: 1,
          explanation: "الحلقة تنكسر في منتصفها تقريبًا → O(n/2) = O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q17(n):\n    for i in range(1, n):\n        for j in range(1, i):\n            if i % j == 0:\n                print(i, j)",
          options: ["O(n²)", "O(n log n)", "O(n)", "O(n³)"],
          correct: 1,
          explanation: "عدد القواسم لكل عدد تقريبًا log n → O(n log n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q18(n):\n    if n == 1:\n        return 1\n    return q18(n//2)",
          options: ["O(n)", "O(log n)", "O(1)", "O(n²)"],
          correct: 1,
          explanation: "n ينخفض إلى النصف في كل استدعاء → O(log n).",
        },
        {
          question: "ما هو التعقيد المكاني لهذه الدالة؟",
          code: "def q19(n):\n    if n == 0:\n        return 0\n    return 1 + q19(n-1)",
          options: ["O(n)", "O(1)", "O(log n)", "O(n²)"],
          correct: 0,
          explanation: "كل استدعاء يُضاف إلى stack → O(n).",
        },
        {
          question: "ما هو التعقيد الزمني لهذه الدالة؟",
          code: "def q20(n):\n    for i in range(n):\n        print('Hello')\n    print('Done')",
          options: ["O(n)", "O(1)", "O(n log n)", "O(n²)"],
          correct: 0,
          explanation: "الطباعة داخل حلقة n مرات → O(n).",
        },
      ];

      let currentPage = 0;

      function renderPage(page) {
        const container = document.getElementById("quiz-container");
        container.innerHTML = "";

        const start = page * QUESTIONS_PER_PAGE;
        const end = start + QUESTIONS_PER_PAGE;
        const pageQuestions = allQuestions.slice(start, end);

        pageQuestions.forEach((q, index) => {
          const qIndex = start + index;
          const div = document.createElement("div");
          div.className =
            "glass-card rounded-xl p-5 shadow-lg hover:shadow-indigo-500/20 transition-all duration-300";

          let optionsHTML = "";
          q.options.forEach((opt, idx) => {
            optionsHTML += `
            <label class="block py-1 cursor-pointer">
              <input type="radio" name="q${qIndex}" value="${idx}" class="ml-2 accent-indigo-500">
              ${String.fromCharCode(65 + idx)}. ${opt}
            </label>`;
          });

          div.innerHTML = `
          <h2 class="font-semibold text-lg mb-3">${qIndex + 1}. ${
            q.question
          }</h2>
          <pre><code>${q.code}</code></pre>
          <div class="mb-4 space-y-2">${optionsHTML}</div>
          <button onclick="checkAnswer(this, ${qIndex})" class="w-full py-2 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 rounded-lg transition">إرسال الإجابة</button>
          <div id="result-${qIndex}" class="mt-4 hidden"></div>
        `;
          container.appendChild(div);
        });

        updatePaginationButtons();
      }

      function updatePaginationButtons() {
        const totalPages = Math.ceil(allQuestions.length / QUESTIONS_PER_PAGE);
        document.getElementById("page-info").textContent = `الصفحة ${
          currentPage + 1
        } من ${totalPages}`;
        document.getElementById("prev-btn").disabled = currentPage === 0;
        document.getElementById("next-btn").disabled =
          (currentPage + 1) * QUESTIONS_PER_PAGE >= allQuestions.length;
      }

      function goToNextPage() {
        if ((currentPage + 1) * QUESTIONS_PER_PAGE < allQuestions.length) {
          currentPage++;
          renderPage(currentPage);
        }
      }

      function goToPrevPage() {
        if (currentPage > 0) {
          currentPage--;
          renderPage(currentPage);
        }
      }

      function checkAnswer(button, qIndex) {
        const q = allQuestions[qIndex];
        const selected = document.querySelector(
          `input[name="q${qIndex}"]:checked`
        );
        const resultDiv = document.getElementById(`result-${qIndex}`);
        resultDiv.classList.remove("hidden");

        if (!selected) {
          resultDiv.innerHTML = `<p class="text-red-400">⚠️ لم تقم باختيار إجابة.</p>`;
          return;
        }

        const selectedIndex = parseInt(selected.value);
        const correctOptionText = q.options[q.correct];

        if (selectedIndex === q.correct) {
          resultDiv.innerHTML = `
          <p class="text-green-400 font-medium">✅ الإجابة صحيحة!</p>
          <p class="mt-1 text-sm text-right">${q.explanation}</p>
        `;
        } else {
          resultDiv.innerHTML = `
          <p class="text-red-400 font-medium">❌ خطأ! الإجابة الصحيحة هي: (${String.fromCharCode(
            65 + q.correct
          )}) ${correctOptionText}</p>
          <p class="mt-1 text-sm text-right">${q.explanation}</p>
        `;
        }

        button.disabled = true;
        button.classList.add("opacity-60");
      }

      window.onload = () => renderPage(currentPage);
      document
        .getElementById("next-btn")
        .addEventListener("click", goToNextPage);
      document
        .getElementById("prev-btn")
        .addEventListener("click", goToPrevPage);
    </script>
  </body>
</html>

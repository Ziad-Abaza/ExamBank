{
  "tutorials": [
    {
      "title": "Tutorial 1 - Introduction to Software Engineering and Software Processes",
      "content": [
        {
          "id": 1,
          "text": "The types of software maintenance are Corrective, Adaptive, Perfective, and Preventative.",
          "highlight": [
            "Corrective",
            "Adaptive",
            "Perfective",
            "Preventative",
            "software maintenance"
          ]
        },
        {
          "id": 2,
          "text": "The main objective of Adaptive Maintenance is altering software to fit changing software.",
          "highlight": [
            "Adaptive Maintenance",
            "altering software",
            "changing software"
          ]
        },
        {
          "id": 3,
          "text": "The primary goal of Perfective Maintenance is meeting new requirements.",
          "highlight": ["Perfective Maintenance", "new requirements"]
        },
        {
          "id": 4,
          "text": "Preventative is a type of maintenance that involves reducing further maintenance needs.",
          "highlight": ["Preventative", "reducing maintenance"]
        },
        {
          "id": 5,
          "text": "The primary purpose of the Software Development Life Cycle (SDLC) is to provide a structured process for developing high-quality software.",
          "highlight": ["SDLC", "structured process", "high-quality software"]
        },
        {
          "id": 6,
          "text": "SDLC specifies the tasks performed at various stages by a software engineer or developer.",
          "highlight": ["SDLC", "tasks", "software engineer", "developer"]
        },
        {
          "id": 7,
          "text": "The SDLC ensures that the product meets customer expectations.",
          "highlight": ["SDLC", "customer expectations"]
        },
        {
          "id": 8,
          "text": "Planning and Requirement Analysis stage involves gathering information to create the basic plan for the project.",
          "highlight": [
            "Planning",
            "Requirement Analysis",
            "gathering information"
          ]
        },
        {
          "id": 9,
          "text": "The purpose of the Planning and Requirement Analysis stage is to understand what is needed for the project.",
          "highlight": ["Planning", "Requirement Analysis", "understand needs"]
        },
        {
          "id": 10,
          "text": "Designing Architecture involves selecting the best design idea from the DDS.",
          "highlight": ["Designing Architecture", "DDS", "best design"]
        },
        {
          "id": 11,
          "text": "The DDS document is used to design the software architecture.",
          "highlight": ["DDS", "software architecture"]
        },
        {
          "id": 12,
          "text": "DDS (Design Document Specification) contains different ideas for building the software.",
          "highlight": [
            "DDS",
            "Design Document Specification",
            "building software"
          ]
        },
        {
          "id": 13,
          "text": "Product Testing and Integration stage of SDLC creates test cases and executes them.",
          "highlight": ["Product Testing", "Integration", "test cases", "SDLC"]
        },
        {
          "id": 14,
          "text": "The purpose of testing in the SDLC is to ensure the software works as expected.",
          "highlight": ["testing", "SDLC", "works as expected"]
        },
        {
          "id": 15,
          "text": "The Product Testing and Integration stage is used to find and fix mistakes in the software.",
          "highlight": ["Product Testing", "fix mistakes"]
        },
        {
          "id": 16,
          "text": "Product testing is compared to testing a car before selling it to ensure quality.",
          "highlight": ["Product testing", "quality standards"]
        },
        {
          "id": 17,
          "text": "Client Feedback Collection is NOT a stage in the SDLC.",
          "highlight": ["Client Feedback Collection", "NOT", "SDLC"]
        },
        {
          "id": 18,
          "text": "Maintenance begins after testing identifies issues.",
          "highlight": ["Maintenance", "testing", "issues"]
        },
        {
          "id": 19,
          "text": "In agile processes, planning is incremental and adaptable to changing customer requirements.",
          "highlight": ["agile", "incremental", "changing requirements"]
        },
        {
          "id": 20,
          "text": "The main goal of software maintenance is to ensure the software continues to work well after release.",
          "highlight": ["software maintenance", "work well", "after release"]
        },
        {
          "id": 21,
          "text": "Waterfall Model does not adapt well to uncertain projects because it requires stable requirements.",
          "highlight": [
            "Waterfall Model",
            "uncertain projects",
            "stable requirements"
          ]
        },
        {
          "id": 22,
          "text": "Waterfall Model is known as a linear-sequential life cycle model.",
          "highlight": ["Waterfall Model", "linear-sequential"]
        },
        {
          "id": 23,
          "text": "Inflexibility to changes is one of the disadvantages of the Waterfall Model.",
          "highlight": ["Inflexibility", "disadvantages", "Waterfall Model"]
        },
        {
          "id": 24,
          "text": "Incremental development is a series of versions where each adds functionality to the previous one.",
          "highlight": ["Incremental development", "versions", "functionality"]
        }
      ]
    },
    {
      "title": "Tutorial 2 - Software Requirements and Requirements Engineering",
      "content": [
        {
          "id": 1,
          "text": "Requirement may range from a high-level abstract statement to a detailed functional specification.",
          "highlight": ["Requirement", "abstract", "functional specification"]
        },
        {
          "id": 2,
          "text": "Software engineering is an engineering discipline concerned with all aspects of software production.",
          "highlight": ["Software engineering", "software production"]
        },
        {
          "id": 3,
          "text": "Requirements engineering is a subset of systems engineering concerned with defining the system at successive levels of abstraction.",
          "highlight": [
            "Requirements engineering",
            "systems engineering",
            "abstraction"
          ]
        },
        {
          "id": 4,
          "text": "Business Requirements are the essential activities for developing the software.",
          "highlight": ["Business Requirements", "essential activities"]
        },
        {
          "id": 5,
          "text": "User Engineering describes the services and operational constraints of the system to users.",
          "highlight": ["User Engineering", "services", "constraints"]
        },
        {
          "id": 6,
          "text": "Functional Requirements describe what the software should do.",
          "highlight": ["Functional Requirements", "software behavior"]
        },
        {
          "id": 7,
          "text": "Non-Functional Requirements describe software properties.",
          "highlight": ["Non-Functional Requirements", "software properties"]
        },
        {
          "id": 8,
          "text": "Domain requirements describe constraints on the system from its domain of operation.",
          "highlight": ["Domain requirements", "constraints", "domain"]
        },
        {
          "id": 9,
          "text": "Stated requirements are provided by a user or customer at the beginning of development.",
          "highlight": ["Stated requirements", "user", "beginning"]
        }
      ]
    },
    {
      "title": "Tutorial 3 - Architectural Patterns",
      "content": [
        {
          "id": 1,
          "text": "Validation (Testing) is important for checking that it does what the customer wants.",
          "highlight": ["Validation", "Testing", "customer wants"]
        },
        {
          "id": 2,
          "text": "Maintenance & Evolution are used for changing the system in response to changing customer needs.",
          "highlight": [
            "Maintenance",
            "Evolution",
            "changing system",
            "customer needs"
          ]
        },
        {
          "id": 3,
          "text": "Reuse in Software Engineering is used to avoid duplication of effort for problems that already have existing solutions, which saves resources.",
          "highlight": [
            "Reuse",
            "Software Engineering",
            "avoid duplication",
            "existing solutions",
            "saves resources"
          ]
        },
        {
          "id": 4,
          "text": "A pattern is the outline of a reusable solution to a recurring problem encountered in a particular context.",
          "highlight": [
            "pattern",
            "reusable solution",
            "recurring problem",
            "particular context"
          ]
        },
        {
          "id": 5,
          "text": "Patterns provide a common language between developers to improve software quality and reduce development time.",
          "highlight": [
            "Patterns",
            "common language",
            "developers",
            "software quality",
            "reduce development time"
          ]
        },
        {
          "id": 6,
          "text": "It is important to ensure that the architecture satisfies the software requirements, both functional (What the software should do) and nonfunctional (How the software should do).",
          "highlight": [
            "architecture",
            "software requirements",
            "functional",
            "nonfunctional"
          ]
        },
        {
          "id": 7,
          "text": "When determining the architectural design, the Non-Functional Requirements are more important than the functional requirements.",
          "highlight": [
            "architectural design",
            "Non-Functional Requirements",
            "functional requirements"
          ]
        }
      ]
    },
    {
      "title": "Tutorial 4 – Activity Diagrams",
      "content": [
        {
          "id": 1,
          "text": "Business processes define who, in what order, needing which resources, and with what consequences, do what in a business.",
          "highlight": [
            "Business processes",
            "who",
            "order",
            "resources",
            "consequences"
          ]
        },
        {
          "id": 2,
          "text": "Business processes get an understanding of what a business does.",
          "highlight": ["Business processes", "understanding", "business"]
        },
        {
          "id": 3,
          "text": "Business Rules constrain how a business is run.",
          "highlight": ["Business Rules", "constrain", "business"]
        },
        {
          "id": 4,
          "text": "Business Rules provide quick and easy access whenever there is a change.",
          "highlight": ["Business Rules", "quick access", "change"]
        },
        {
          "id": 5,
          "text": "Renting a car is an example of Business processes.",
          "highlight": ["Renting a car", "Business processes"]
        },
        {
          "id": 6,
          "text": "The car allocated is the lowest mileage car that is available in the chosen group, an example of Business Rules.",
          "highlight": ["car allocated", "lowest mileage", "Business Rules"]
        },
        {
          "id": 7,
          "text": "Activity Diagram shows a process as a set of activities, showing their sequences, and where activities can be carried out in parallel.",
          "highlight": [
            "Activity Diagram",
            "process",
            "activities",
            "sequences",
            "parallel"
          ]
        },
        {
          "id": 8,
          "text": "Activity is a task that a person or a computer might perform.",
          "highlight": ["Activity", "task", "person", "computer"]
        },
        {
          "id": 9,
          "text": "Business Rules Representation Techniques are the language used in expressing business rules; it should be well defined, structured, and easy for business people to understand.",
          "highlight": [
            "Business Rules Representation Techniques",
            "language",
            "well defined",
            "structured",
            "easy to understand"
          ]
        },
        {
          "id": 10,
          "text": "Workflow is defined as a sequence of activities that produces a result of observable value.",
          "highlight": [
            "Workflow",
            "sequence",
            "activities",
            "result",
            "observable value"
          ]
        }
      ]
    },
    {
      "title": "Tutorial 6 – Use-Case Models",
      "content": [
        {
          "id": 1,
          "text": "Use-Case Model defines what a proposed system should do from a user’s perspective.",
          "highlight": ["Use-Case Model", "system", "user’s perspective"]
        },
        {
          "id": 2,
          "text": "Use-Case Model enables the development of software that will meet users' needs.",
          "highlight": ["Use-Case Model", "development", "users' needs"]
        },
        {
          "id": 3,
          "text": "Use-Case Model provides a basis for a contract between the customer and the developer.",
          "highlight": ["Use-Case Model", "contract", "customer", "developer"]
        },
        {
          "id": 4,
          "text": "Use-Case Model defines the initial set of user requirements to determine the people involved, and the events that initiate some work to be done.",
          "highlight": [
            "Use-Case Model",
            "initial user requirements",
            "people involved",
            "events"
          ]
        },
        {
          "id": 5,
          "text": "Use-Case Model defines the scope of a system, as they represent the interaction of a system with its environment.",
          "highlight": ["Use-Case Model", "scope", "interaction", "environment"]
        },
        {
          "id": 6,
          "text": "Use-Case Model offers a common language for agreeing on the functions of the software system.",
          "highlight": [
            "Use-Case Model",
            "common language",
            "functions",
            "software system"
          ]
        },
        {
          "id": 7,
          "text": "A scenario describes a sequence of interactions between the system and some actors.",
          "highlight": [
            "scenario",
            "sequence",
            "interactions",
            "system",
            "actors"
          ]
        }
      ]
    },
    {
      "title": "Tutorial 7 – Introduction to Software Testing",
      "content": [
        {
          "id": 1,
          "text": "Prototyping is a rapid creation of trial software version that is rejected after evaluation.",
          "highlight": [
            "Prototyping",
            "rapid creation",
            "trial software version",
            "rejected",
            "evaluation"
          ]
        },
        {
          "id": 2,
          "text": "Iterative Approaches are early software versions that are built upon rather than discarded.",
          "highlight": [
            "Iterative Approaches",
            "early software versions",
            "built upon"
          ]
        },
        {
          "id": 3,
          "text": "The developer can refactor the code to improve its structure, readability, or efficiency, making the code as clean and maintainable as possible.",
          "highlight": [
            "developer",
            "refactor",
            "structure",
            "readability",
            "efficiency",
            "clean",
            "maintainable"
          ]
        },
        {
          "id": 4,
          "text": "Software Quality is the software characteristics to fit its purpose.",
          "highlight": ["Software Quality", "characteristics", "fit purpose"]
        },
        {
          "id": 5,
          "text": "Software Quality Factors are the attributes of a software product.",
          "highlight": [
            "Software Quality Factors",
            "attributes",
            "software product"
          ]
        },
        {
          "id": 6,
          "text": "Product Operation Requirements define how the product will be used.",
          "highlight": ["Product Operation Requirements", "define", "used"]
        },
        {
          "id": 7,
          "text": "Product Revision Requirements relate to how the product will change.",
          "highlight": ["Product Revision Requirements", "product change"]
        },
        {
          "id": 8,
          "text": "Product Transition Requirements define how the product will be modified for different operating environments.",
          "highlight": [
            "Product Transition Requirements",
            "modified",
            "operating environments"
          ]
        },
        {
          "id": 9,
          "text": "In Product Operation Requirements, Correctness means a software satisfies its specifications and achieves the user’s objectives.",
          "highlight": [
            "Correctness",
            "Product Operation Requirements",
            "software satisfies",
            "specifications",
            "user’s objectives"
          ]
        },
        {
          "id": 10,
          "text": "Reliability in product operation requirements means when software performs its function with required precision.",
          "highlight": [
            "Reliability",
            "product operation requirements",
            "function",
            "precision"
          ]
        },
        {
          "id": 11,
          "text": "In Product Operation Requirements, Efficiency is the amount of resources required by a program to perform a function.",
          "highlight": [
            "Efficiency",
            "Product Operation Requirements",
            "resources",
            "program",
            "perform function"
          ]
        },
        {
          "id": 12,
          "text": "Integrity in product operation requirements is preventing access to software/data by unauthorized persons.",
          "highlight": [
            "Integrity",
            "product operation requirements",
            "preventing access",
            "unauthorized persons"
          ]
        },
        {
          "id": 13,
          "text": "Usability in product operation requirements is the effort required to learn, operate, prepare input, and interpret output of a program.",
          "highlight": [
            "Usability",
            "product operation requirements",
            "effort",
            "learn",
            "operate",
            "input",
            "output"
          ]
        },
        {
          "id": 14,
          "text": "In product revision requirements, Maintainability is the effort required to locate and fix an error in an operational program.",
          "highlight": [
            "Maintainability",
            "product revision requirements",
            "locate",
            "fix error",
            "operational program"
          ]
        },
        {
          "id": 15,
          "text": "Testability in product revision requirements is how to test a program to ensure it performs its function.",
          "highlight": [
            "Testability",
            "product revision requirements",
            "test program",
            "performs function"
          ]
        },
        {
          "id": 16,
          "text": "Flexibility is an effort in Product Revision Requirements to modify an operational program.",
          "highlight": [
            "Flexibility",
            "Product Revision Requirements",
            "modify",
            "operational program"
          ]
        },
        {
          "id": 17,
          "text": "In product transition requirements, portability is the effort required to transfer a program from one hardware configuration and/or software system environment to another.",
          "highlight": [
            "portability",
            "product transition requirements",
            "transfer",
            "hardware configuration",
            "software environment"
          ]
        },
        {
          "id": 18,
          "text": "Reusability is when software is used in other applications related to the packaging and scope of the functions that programs perform.",
          "highlight": [
            "Reusability",
            "software",
            "other applications",
            "packaging",
            "scope",
            "functions"
          ]
        },
        {
          "id": 19,
          "text": "Interoperability in product transition requirements is the effort required to couple one system with another.",
          "highlight": [
            "Interoperability",
            "product transition requirements",
            "couple",
            "system"
          ]
        },
        {
          "id": 20,
          "text": "Increasing integrity within a system to make it more secure could affect efficiency.",
          "highlight": ["integrity", "system", "secure", "affect efficiency"]
        },
        {
          "id": 21,
          "text": "Usability testing refers to testing the user interface.",
          "highlight": ["Usability testing", "testing", "user interface"]
        },
        {
          "id": 22,
          "text": "Requirements-based testing is used to check that a system meets the customer’s requirements.",
          "highlight": [
            "Requirements-based testing",
            "check",
            "system",
            "customer requirements"
          ]
        },
        {
          "id": 23,
          "text": "Developmental testing refers to all of the testing carried out by the team developing the software.",
          "highlight": [
            "Developmental testing",
            "testing",
            "team",
            "developing software"
          ]
        },
        {
          "id": 24,
          "text": "Regression testing is a form of testing during development or system maintenance to check that fixing one bug has not introduced others.",
          "highlight": [
            "Regression testing",
            "testing",
            "development",
            "system maintenance",
            "fixing bug"
          ]
        },
        {
          "id": 25,
          "text": "Correctness is measured by defects (Bugs) per a thousand lines of code (Defects per KLOC).",
          "highlight": ["Correctness", "measured", "defects", "Bugs", "KLOC"]
        },
        {
          "id": 26,
          "text": "Maintainability is measured indirectly using the Mean Time To Change (MTTC).",
          "highlight": [
            "Maintainability",
            "measured",
            "Mean Time To Change",
            "MTTC"
          ]
        },
        {
          "id": 27,
          "text": "Integrity is a proportion of 'attacks' on a product which means the probability that an attack will occur within a given time, and the probability that it will be resisted.",
          "highlight": [
            "Integrity",
            "attacks",
            "probability",
            "attack",
            "resisted"
          ]
        }
      ]
    }
  ]
}
